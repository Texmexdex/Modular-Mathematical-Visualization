<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Audio Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #eee; font-family: sans-serif; }
        canvas { display: block; position: fixed; top: 0; left: 0; z-index: -1; } /* Keep canvas in background */

        /* Left Controls Panel */
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            color: white;
            z-index: 10; /* Ensure controls are above canvas */
            max-width: 280px; /* Limit width */
        }
        #controls button {
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 5px 10px;
            margin: 5px 0;
            cursor: pointer;
            border-radius: 3px;
            display: inline-block; /* Align buttons */
            margin-right: 5px;
        }
        #controls button:hover { background: #555; }
        #audioPlayer { width: 100%; height: 40px; margin-top: 10px;}
        #status { margin-top: 10px; font-size: 0.8em; color: #aaa; }

        /* Drag & Drop Zone Styling */
        #audioDropZone {
            border: 2px dashed #555;
            padding: 20px;
            text-align: center;
            border-radius: 5px;
            margin-top: 15px;
            cursor: pointer; /* Make it look clickable */
            transition: background-color 0.2s, border-color 0.2s;
        }
        #audioDropZone.dragover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: #aaa;
        }
        #audioDropZone span {
            display: block;
            font-size: 0.9em;
            color: #aaa;
            pointer-events: none; /* Allow click/drop event to reach the zone */
        }
         #audioDropZone img {
            margin: 0 auto 0.5rem auto; /* Center icon */
            pointer-events: none;
            opacity: 0.7;
        }


        /* Basic lil-gui positioning */
        .lil-gui {
            position: absolute !important; /* Ensure positioning */
            top: 10px !important;
            right: 10px !important;
            z-index: 10; /* Ensure GUI is above canvas */
            /* Removed max-height and overflow-y */
        }
    </style>
</head>
<body>
    <div id="controls">
        <h4>Audio Controls</h4>
        <div>
             <button id="playAudioButton">Play</button>
             <button id="pauseAudioButton">Pause</button>
        </div>
        <audio id="audioPlayer" src="" controls></audio>

        <div id="audioDropZone">
            <img src="https://cdn.jsdelivr.net/npm/lucide-static@latest/icons/music.svg" alt="Audio" width="24" height="24" style="filter: invert(0.7);"/>
            <span>Drag & Drop or Click to Browse</span>
        </div>
        <input type="file" id="audioFilePicker" accept="audio/*" style="display: none;">


        <div id="status">Drop or select an audio file.</div>
    </div>

    <canvas id="visualizerCanvas"></canvas>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        // --- Global Variables ---
        let scene, camera, renderer, controls, clock, gui;
        let points = [];
        let lineSegments, lineMaterial;
        let pointMesh, pointMaterial;

        // Audio State
        let audioContext;
        let analyser;
        let audioSource;
        let frequencyData;
        let audioElement;
        let isAudioSetup = false;
        let isAudioPlaying = false;
        const fftSize = 512;

        // --- Parameters ---
        const parameters = {
            // Visual Params
            divisions: 150,
            radius: 5,
            multiplier: 2, // Base multiplier when not driven by audio
            lineWidth: 1.0,
            lineColor: '#00ffff', // Base line color
            lineOpacity: 0.7,
            showPoints: true,
            pointSize: 0.05,
            pointColor: '#ffffff',
            // Fallback Animation Params
            autoAnimateMultiplier: true, // Enable fallback animation
            autoMultiplierSpeed: 0.2, // Speed factor for sin wave animation
            // Audio Control Mode
            audioControlMode: 'Single Target', // 'Single Target', 'Multi Target'
            // Single Target Params
            audioTargetParameter: 'Multiplier', // 'Multiplier', 'Radius', 'Line Opacity', 'Line Hue Shift'
            audioParamSource: 'Bass', // 'Bass', 'Mid', 'Treble', 'Average'
            // Mapping Ranges (used by Single or Multi mode as needed)
            audioMultiplierMin: 2,
            audioMultiplierMax: 50,
            audioRadiusMin: 4,
            audioRadiusMax: 8,
            audioOpacityMin: 0.2,
            audioOpacityMax: 1.0,
            audioHueShiftMin: -0.1,
            audioHueShiftMax: 0.1,
            // General Audio Params
            audioSensitivity: 1.0,
            audioSmoothing: 0.04,
            // Internal state for smoothing / lerping
            _currentMultiplier: 2,
            _currentRadius: 5,
            _currentLineOpacity: 0.7,
            _currentHueShift: 0.0,
            _baseLineHSL: { h: 0, s: 0, l: 0 },
        };

        // DOM Elements
        const canvas = document.getElementById('visualizerCanvas');
        const playButton = document.getElementById('playAudioButton');
        const pauseButton = document.getElementById('pauseAudioButton');
        const statusDiv = document.getElementById('status');
        const audioDropZone = document.getElementById('audioDropZone');
        const audioFilePicker = document.getElementById('audioFilePicker'); // Hidden input
        audioElement = document.getElementById('audioPlayer');

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // Materials
            lineMaterial = new THREE.LineBasicMaterial({
                color: parameters.lineColor,
                linewidth: parameters.lineWidth,
                opacity: parameters.lineOpacity,
                transparent: true,
                depthWrite: false
            });
            pointMaterial = new THREE.PointsMaterial({
                color: parameters.pointColor,
                size: parameters.pointSize,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9,
                depthWrite: false
            });

            // Initialize internal states
            parameters._currentMultiplier = parameters.multiplier;
            parameters._currentRadius = parameters.radius;
            parameters._currentLineOpacity = parameters.lineOpacity;
            parameters._currentHueShift = 0.0;
            lineMaterial.color.getHSL(parameters._baseLineHSL);

            // Initial Geometry
            createPoints();
            createLineGeometry();
            createPointGeometry();
            updateLines();

            // GUI Setup
            setupGUI();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            playButton.addEventListener('click', playAudio, false);
            pauseButton.addEventListener('click', pauseAudio, false);
            audioElement.addEventListener('error', handleAudioElementError);
            setupAudioDropZoneAndPicker(); // Setup drag/drop AND click-to-browse

            animate();
        }

        // --- Audio Handling ---
        function setupAudioContext() {
            if (isAudioSetup) return true;
            try {
                if (!audioContext) {
                     audioContext = new (window.AudioContext || window.webkitAudioContext)();
                     analyser = audioContext.createAnalyser();
                     analyser.fftSize = fftSize;
                     const bufferLength = analyser.frequencyBinCount;
                     frequencyData = new Uint8Array(bufferLength);
                     console.log("AudioContext created.");
                }
                 if (audioContext.state === 'suspended') {
                     audioContext.resume().then(() => { console.log("AudioContext resumed."); isAudioSetup = true; }).catch(e => { throw e; });
                 } else { isAudioSetup = true; }
                 if(statusDiv) statusDiv.textContent = "Audio ready.";
                 return true;
            } catch (e) {
                console.error("Error setting up AudioContext:", e); if(statusDiv) statusDiv.textContent = "Error: Web Audio API setup failed."; isAudioSetup = false; return false;
            }
        }
        function connectAudioSource() {
            if (!isAudioSetup || !audioContext || !analyser || !audioElement) return;
            if (!audioSource || audioSource.mediaElement !== audioElement) {
                 try {
                     if (audioSource) { try { audioSource.disconnect(); } catch(e) {} }
                     audioSource = audioContext.createMediaElementSource(audioElement);
                     audioSource.connect(analyser);
                     analyser.connect(audioContext.destination); // Hear audio
                     console.log("Audio source connected.");
                 } catch (e) { console.error("Error connecting audio source:", e); if(statusDiv) statusDiv.textContent = "Error connecting audio."; audioSource = null; }
             } else { // Reconnect if needed (e.g., after context resume)
                 try { audioSource.disconnect(); } catch(e) {}
                 try { audioSource.connect(analyser); analyser.connect(audioContext.destination); } catch(e) { console.error("Error reconnecting audio source:", e); }
             }
        }

        // --- Drag & Drop AND Click-to-Browse Setup ---
        function setupAudioDropZoneAndPicker() {
            // Drag and Drop Listeners
            audioDropZone.addEventListener('dragover', (event) => {
                event.preventDefault();
                audioDropZone.classList.add('dragover');
            });
            audioDropZone.addEventListener('dragleave', () => {
                audioDropZone.classList.remove('dragover');
            });
            audioDropZone.addEventListener('drop', (event) => {
                event.preventDefault();
                audioDropZone.classList.remove('dragover');
                const files = event.dataTransfer.files;
                handleFileSelection(files); // Use common handler
            });

            // Click Listener for Drop Zone
            audioDropZone.addEventListener('click', () => {
                audioFilePicker.click(); // Trigger hidden file input
            });

            // Change Listener for Hidden File Input
            audioFilePicker.addEventListener('change', (event) => {
                const files = event.target.files;
                handleFileSelection(files); // Use common handler
                // Reset file input value to allow selecting the same file again
                event.target.value = null;
            });
        }

        // Common function to handle file selection from drop or browse
        function handleFileSelection(files) {
             if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('audio/')) {
                    console.log("Audio file selected:", file.name);
                    if (setupAudioContext()) {
                         handleDroppedAudioFile(file); // Process the file
                    } else {
                         if(statusDiv) statusDiv.textContent = "Audio Context failed.";
                    }
                } else {
                    if(statusDiv) statusDiv.textContent = "Selected file not audio.";
                }
            }
        }

        // Renamed from handleDroppedAudioFile for clarity
        function handleAudioFileProcessing(file) {
             if (!isAudioSetup) { console.error("Cannot handle audio file, AC not ready."); return; }
            pauseAudio();
            if (audioElement.src && audioElement.src.startsWith('blob:')) { URL.revokeObjectURL(audioElement.src); console.log("Revoked previous Blob URL."); }
            const objectURL = URL.createObjectURL(file);
            audioElement.src = objectURL; audioElement.load();
            if(statusDiv) statusDiv.textContent = `Loaded: ${file.name}. Press Play.`;
            connectAudioSource(); isAudioPlaying = false;
        }
        // Keep original name for compatibility if needed elsewhere, just call the new one
        function handleDroppedAudioFile(file) { handleAudioFileProcessing(file); }


        function playAudio() {
            if (!isAudioSetup) { if (!setupAudioContext()) return; }
             if (audioContext.state === 'suspended') { audioContext.resume(); }
            // Check if src is set (it should be a blob URL now)
            if (!audioElement.src || audioElement.src === window.location.href || audioElement.src.startsWith('file://')) {
                 if(statusDiv) statusDiv.textContent = "Error: No audio loaded. Drop or select file."; return;
             }
             connectAudioSource(); if (!audioSource) { if(statusDiv) statusDiv.textContent = "Error: Audio source not connected."; return; }
            audioElement.play().then(() => { isAudioPlaying = true; if(statusDiv) statusDiv.textContent = "Playing..."; console.log("Playback started."); }).catch(e => { console.error("Error playing audio:", e); if(statusDiv) statusDiv.textContent = `Error playing: ${e.message}`; isAudioPlaying = false; });
        }
        function pauseAudio() { audioElement.pause(); isAudioPlaying = false; if(statusDiv) statusDiv.textContent = "Paused."; console.log("Playback paused."); }
        function handleAudioElementError(e) {
             console.error("Audio Element Error:", audioElement.error); let errorMsg = "Error loading/playing audio."; /* ... */ if(statusDiv) statusDiv.textContent = errorMsg; isAudioPlaying = false;
             if (audioElement.error) errorMsg = `Audio Error (Code: ${audioElement.error.code})`;
             if(statusDiv) statusDiv.textContent = errorMsg; isAudioPlaying = false;
         }

        // --- Geometry Creation & Update ---
        // (No changes needed in these core functions)
         function createPoints() { points = []; const divs = Math.max(1, parameters.divisions); const angleStep = (2 * Math.PI) / divs; const radiusToUse = parameters.radius; for (let i = 0; i < divs; i++) { const angle = i * angleStep; const x = radiusToUse * Math.cos(angle); const y = radiusToUse * Math.sin(angle); points.push(new THREE.Vector3(x, y, 0)); } }
        function createLineGeometry() { if (lineSegments) { scene.remove(lineSegments); lineSegments.geometry.dispose(); } const divs = Math.max(1, parameters.divisions); const lineGeometry = new THREE.BufferGeometry(); const positions = new Float32Array(divs * 2 * 3); lineGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); lineGeometry.setDrawRange(0, 0); lineSegments = new THREE.LineSegments(lineGeometry, lineMaterial); scene.add(lineSegments); }
        function createPointGeometry() { if (pointMesh) { scene.remove(pointMesh); pointMesh.geometry.dispose(); pointMesh = null; } if (!parameters.showPoints || points.length === 0) return; const pointGeometry = new THREE.BufferGeometry(); const positions = new Float32Array(points.length * 3); points.forEach((p, i) => { if(p) { positions[i * 3] = p.x; positions[i * 3 + 1] = p.y; positions[i * 3 + 2] = p.z; }}); pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); pointMesh = new THREE.Points(pointGeometry, pointMaterial); scene.add(pointMesh); }
        function updateLines() { const divs = Math.max(1, parameters.divisions); if (!lineSegments || !lineSegments.geometry.attributes.position || points.length !== divs) { createPoints(); createLineGeometry(); createPointGeometry(); if (!lineSegments || !lineSegments.geometry.attributes.position || points.length !== divs) return; } const currentPointRadius = points[0]?.length() || 0; if (Math.abs(currentPointRadius - parameters.radius) > 0.01) { createPoints(); updatePointGeometryPositions(); } const positions = lineSegments.geometry.attributes.position.array; let index = 0; const c = parameters._currentMultiplier; const maxVertices = divs * 2; for (let x = 0; x < divs; x++) { const y = ((Math.round(x * c) % divs) + divs) % divs; const startPoint = points[x]; const endPoint = points[y]; if (startPoint && endPoint && (index / 3) < maxVertices) { positions[index++] = startPoint.x; positions[index++] = startPoint.y; positions[index++] = startPoint.z; positions[index++] = endPoint.x; positions[index++] = endPoint.y; positions[index++] = endPoint.z; } else { break; } } lineSegments.geometry.setDrawRange(0, index / 3); lineSegments.geometry.attributes.position.needsUpdate = true; }
        function updatePointGeometryPositions() { if (!pointMesh || !pointMesh.geometry.attributes.position || points.length === 0) return; const positions = pointMesh.geometry.attributes.position.array; const maxPoints = Math.min(points.length, positions.length / 3); for(let i = 0; i < maxPoints; i++) { const p = points[i]; if(p) { positions[i * 3] = p.x; positions[i * 3 + 1] = p.y; positions[i * 3 + 2] = p.z; }} pointMesh.geometry.attributes.position.needsUpdate = true; }
        function updatePointMarkersVisuals() { const divs = Math.max(1, parameters.divisions); if (!parameters.showPoints) { if(pointMesh) pointMesh.visible = false; return; } if(!pointMesh || points.length !== divs) { createPointGeometry(); if(!pointMesh) return; } pointMesh.visible = true; pointMaterial.size = parameters.pointSize; pointMaterial.color.set(parameters.pointColor); pointMaterial.opacity = parameters.lineOpacity; if (pointMesh.geometry.attributes.position.count !== points.length) { createPointGeometry(); } else { updatePointGeometryPositions(); } }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const deltaTime = clock.getDelta(); // Get time delta for smooth animations

            let targetMultiplier = parameters.multiplier; // Start with base value
            let targetRadius = parameters.radius;
            let targetOpacity = parameters.lineOpacity;
            let targetHueShift = 0.0; // Target shift is 0 if not driven by audio

            // --- Determine Control Mode ---
            const noAudioSourceLoaded = !audioElement.currentSrc; // Check if src is truly empty or unset

            if (isAudioPlaying && isAudioSetup && analyser && frequencyData) {
                // --- Audio Analysis ---
                analyser.getByteFrequencyData(frequencyData);
                const bufferLength = analyser.frequencyBinCount;
                const bassEndIndex = Math.floor(bufferLength * 0.1);
                const midStartIndex = bassEndIndex;
                const midEndIndex = Math.floor(bufferLength * 0.4);
                const trebleStartIndex = midEndIndex;
                let bassSum = 0, midSum = 0, trebleSum = 0, totalSum = 0;
                const needsBass = parameters.audioControlMode === 'Multi Target' || (parameters.audioControlMode === 'Single Target' && parameters.audioParamSource === 'Bass') || parameters.audioParamSource === 'Average';
                const needsMid = parameters.audioControlMode === 'Multi Target' || (parameters.audioControlMode === 'Single Target' && parameters.audioParamSource === 'Mid') || parameters.audioParamSource === 'Average';
                const needsTreble = parameters.audioControlMode === 'Multi Target' || (parameters.audioControlMode === 'Single Target' && parameters.audioParamSource === 'Treble') || parameters.audioParamSource === 'Average';

                for (let i = 0; i < bufferLength; i++) { const value = frequencyData[i]; if (i < bassEndIndex && needsBass) bassSum += value; else if (i >= midStartIndex && i < midEndIndex && needsMid) midSum += value; else if (i >= trebleStartIndex && needsTreble) trebleSum += value; }
                totalSum = bassSum + midSum + trebleSum;
                const bassAvg = bassEndIndex > 0 ? (bassSum / bassEndIndex) : 0;
                const midAvg = (midEndIndex - midStartIndex > 0) ? (midSum / (midEndIndex - midStartIndex)) : 0;
                const trebleAvg = (bufferLength - trebleStartIndex > 0) ? (trebleSum / (bufferLength - trebleStartIndex)) : 0;
                if (parameters.audioParamSource === 'Average' || parameters.audioControlMode === 'Multi Target') { totalSum = 0; for(let i=0; i<bufferLength; i++) totalSum += frequencyData[i]; }
                const overallAvg = bufferLength > 0 ? (totalSum / bufferLength) : 0;
                const sensitivityFactor = Math.max(0.1, parameters.audioSensitivity);

                // --- Apply Audio to Parameters based on Mode ---
                if (parameters.audioControlMode === 'Single Target') {
                    let drivingValue = 0;
                    switch(parameters.audioParamSource) { case 'Bass': drivingValue = bassAvg; break; case 'Mid': drivingValue = midAvg; break; case 'Treble': drivingValue = trebleAvg; break; default: drivingValue = overallAvg; break; }
                    const normalizedValue = drivingValue / 255.0; const scaledValue = Math.pow(normalizedValue, sensitivityFactor);
                    switch(parameters.audioTargetParameter) {
                        case 'Multiplier': targetMultiplier = mapValue(scaledValue, 0, 1, parameters.audioMultiplierMin, parameters.audioMultiplierMax); break;
                        case 'Radius': targetRadius = mapValue(scaledValue, 0, 1, parameters.audioRadiusMin, parameters.audioRadiusMax); break;
                        case 'Line Opacity': targetOpacity = mapValue(scaledValue, 0, 1, parameters.audioOpacityMin, parameters.audioOpacityMax); break;
                        case 'Line Hue Shift': targetHueShift = mapValue(scaledValue, 0, 1, parameters.audioHueShiftMin, parameters.audioHueShiftMax); break;
                    }
                } else { // Multi Target Mode
                    const normBass = bassAvg / 255.0; const scaledBass = Math.pow(normBass, sensitivityFactor); targetMultiplier = mapValue(scaledBass, 0, 1, parameters.audioMultiplierMin, parameters.audioMultiplierMax);
                    const normMid = midAvg / 255.0; const scaledMid = Math.pow(normMid, sensitivityFactor); targetRadius = mapValue(scaledMid, 0, 1, parameters.audioRadiusMin, parameters.audioRadiusMax);
                    const normTreble = trebleAvg / 255.0; const scaledTreble = Math.pow(normTreble, sensitivityFactor); targetHueShift = mapValue(scaledTreble, 0, 1, parameters.audioHueShiftMin, parameters.audioHueShiftMax);
                    // Opacity could be driven by overallAvg in multi-mode, for example
                    // const normOverall = overallAvg / 255.0; const scaledOverall = Math.pow(normOverall, sensitivityFactor); targetOpacity = mapValue(scaledOverall, 0, 1, parameters.audioOpacityMin, parameters.audioOpacityMax);
                }
            } else if (noAudioSourceLoaded && parameters.autoAnimateMultiplier) {
                // --- Fallback Animation ---
                // Use a sine wave for smooth looping animation based on elapsed time
                const time = clock.getElapsedTime();
                const sinValue = 0.5 + 0.5 * Math.sin(time * parameters.autoMultiplierSpeed); // Oscillates 0-1
                targetMultiplier = mapValue(sinValue, 0, 1, parameters.audioMultiplierMin, parameters.audioMultiplierMax); // Use audio range for consistency
                // Keep other params at their base values in fallback mode
                targetRadius = parameters.radius;
                targetOpacity = parameters.lineOpacity;
                targetHueShift = 0.0;
            } else {
                // --- Audio Loaded but Paused or Fallback Disabled ---
                // Target is just the base value set by GUI
                targetMultiplier = parameters.multiplier;
                targetRadius = parameters.radius;
                targetOpacity = parameters.lineOpacity;
                targetHueShift = 0.0;
            }

            // --- Smoothly Interpolate Internal State Towards Targets ---
            const smoothing = parameters.audioSmoothing; // Use the same smoothing factor for all
            parameters._currentMultiplier = lerp(parameters._currentMultiplier, targetMultiplier, smoothing);
            parameters._currentRadius = lerp(parameters._currentRadius, targetRadius, smoothing);
            parameters._currentLineOpacity = lerp(parameters._currentLineOpacity, targetOpacity, smoothing);
            parameters._currentHueShift = lerp(parameters._currentHueShift, targetHueShift, smoothing);

            // --- Apply Final Parameters for Drawing ---
            parameters.multiplier = parameters._currentMultiplier; // Update for GUI listen()
            parameters.radius = parameters._currentRadius; // Update for GUI listen() and geometry creation
            lineMaterial.opacity = parameters._currentLineOpacity; // Update material opacity
            pointMaterial.opacity = parameters._currentLineOpacity; // Link point opacity

            // Apply Hue Shift
            const currentBaseColor = new THREE.Color(parameters.lineColor);
            currentBaseColor.getHSL(parameters._baseLineHSL);
            let shiftedHue = (parameters._baseLineHSL.h + parameters._currentHueShift) % 1.0;
            if (shiftedHue < 0) shiftedHue += 1.0;
            lineMaterial.color.setHSL(shiftedHue, parameters._baseLineHSL.s, parameters._baseLineHSL.l);

            // Update visuals
            updateLines();
            updatePointMarkersVisuals();
            renderer.render(scene, camera);

             // Update GUI display
             if (gui) {
                updateGUIListeningState(isAudioPlaying);
             }
        }

        // --- Helper Functions ---
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function mapValue(value, inMin, inMax, outMin, outMax) { if (inMax - inMin === 0) return outMin; const clampedValue = Math.max(inMin, Math.min(value, inMax)); const normalized = (clampedValue - inMin) / (inMax - inMin); return normalized * (outMax - outMin) + outMin; }
        function smoothStep(min, max, value) { const x = Math.max(0, Math.min(1, (value - min) / (max - min))); return x * x * (3 - 2 * x); }

        // --- Event Handlers ---
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

        // --- GUI Setup ---
        function setupGUI() {
            if (gui) gui.destroy();
            gui = new GUI();
            gui.title("Controls");

            const visFolder = gui.addFolder('Visuals');
            visFolder.add(parameters, 'divisions', 10, 500, 1).name('Divisions').onChange(() => { createPoints(); createLineGeometry(); createPointGeometry(); updateLines(); });
            visFolder.add(parameters, '_currentRadius', 1, 20, 0.1).name('Radius').listen().onChange(v => { if(!isAudioPlaying) { parameters.radius = v; parameters._currentRadius = v;} });
            visFolder.add(parameters, '_currentMultiplier', 0, 200, 0.01).name('Multiplier').listen().onChange(v => { if (!isAudioPlaying && !parameters.autoAnimateMultiplier) { parameters.multiplier = v; parameters._currentMultiplier = v;} }); // Only allow manual set if no audio AND no fallback anim
            visFolder.add(parameters, 'lineWidth', 0.1, 5, 0.1).name('Line Width').onChange(v => lineMaterial.linewidth = v);
            visFolder.add(parameters, '_currentLineOpacity', 0, 1, 0.01).name('Line Opacity').listen().onChange(v => { if(!isAudioPlaying) { parameters.lineOpacity = v; parameters._currentLineOpacity = v;} });
            visFolder.addColor(lineMaterial.color, 'getHexString').name('Line Color').listen().onChange(v => { if(!isAudioPlaying) { parameters.lineColor = v; lineMaterial.color.set(v); lineMaterial.color.getHSL(parameters._baseLineHSL);} });
            visFolder.add(parameters, 'showPoints').name('Show Points').onChange(updatePointMarkersVisuals);
            visFolder.add(parameters, 'pointSize', 0.01, 1, 0.005).name('Point Size').onChange(v => parameters.pointSize = v);
            visFolder.addColor(parameters, 'pointColor').name('Point Color').onChange(v => parameters.pointColor = v);
            // Fallback Animation Controls
            visFolder.add(parameters, 'autoAnimateMultiplier').name('Auto Animate (No Audio)');
            visFolder.add(parameters, 'autoMultiplierSpeed', 0.01, 1.0, 0.01).name('Auto Anim Speed');


            const audioFolder = gui.addFolder('Audio Mapping');
            audioFolder.add(parameters, 'audioControlMode', ['Single Target', 'Multi Target']).name('Control Mode');
            audioFolder.add(parameters, 'audioTargetParameter', ['Multiplier', 'Radius', 'Line Opacity', 'Line Hue Shift']).name('Target Param (Single)');
            audioFolder.add(parameters, 'audioParamSource', ['Bass', 'Mid', 'Treble', 'Average']).name('Audio Source (Single)');
            audioFolder.add(parameters, 'audioMultiplierMin', 0, 50, 0.1).name('Mult Min');
            audioFolder.add(parameters, 'audioMultiplierMax', 1, 200, 0.1).name('Mult Max');
            audioFolder.add(parameters, 'audioRadiusMin', 1, 10, 0.1).name('Radius Min');
            audioFolder.add(parameters, 'audioRadiusMax', 2, 20, 0.1).name('Radius Max');
            audioFolder.add(parameters, 'audioOpacityMin', 0, 1, 0.01).name('Opacity Min');
            audioFolder.add(parameters, 'audioOpacityMax', 0, 1, 0.01).name('Opacity Max');
            audioFolder.add(parameters, 'audioHueShiftMin', -0.5, 0.5, 0.01).name('Hue Shift Min');
            audioFolder.add(parameters, 'audioHueShiftMax', -0.5, 0.5, 0.01).name('Hue Shift Max');
            audioFolder.add(parameters, 'audioSensitivity', 0.1, 5.0, 0.05).name('Sensitivity');
            audioFolder.add(parameters, 'audioSmoothing', 0.01, 0.5, 0.005).name('Smoothing');


            updateGUIListeningState(false); // Initial state
        }

        function updateGUIListeningState(isListening) {
            // Updates the display of controllers marked with .listen()
            if (!gui) return;
            // Update parameters bound to listen() with their smoothed internal values
            // parameters.multiplier = parameters._currentMultiplier; // Handled by binding GUI to _currentMultiplier now
            // parameters.radius = parameters._currentRadius; // Handled by binding GUI to _currentRadius now
            // parameters.lineOpacity = parameters._currentLineOpacity; // Handled by binding GUI to _currentLineOpacity

            gui.folders.forEach(folder => folder.controllers.forEach(c => {
                if (c._listen) c.updateDisplay();
            }));
            gui.controllers.forEach(c => { // Update top-level controllers too
                 if (c._listen) c.updateDisplay();
            });
        }

        // --- Start ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>

